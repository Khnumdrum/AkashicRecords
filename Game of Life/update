"""
Enhanced Game of Life Program:
- Right-click functionality to remove cells.
- Symbol learning mode and long-term memory for patterns.
- Recall menu for managing saved patterns.
Author: Michael A Fry (GitHub: Khnundrum)
Special thanks to Sistere and Mu.
"""

import pygame
import numpy as np
import random
import json
import os

# Memory storage for learned patterns
MEMORY_FILE = "learned_patterns.json"

# Constants
CELL_SIZE = 10
ROWS, COLS = 50, 50
SCREEN_WIDTH, SCREEN_HEIGHT = COLS * CELL_SIZE, ROWS * CELL_SIZE


class KeyFunction:
    """Manages the state of toggleable keys for the program."""
    def __init__(self):
        self.active_keys = {
            "R": False, "P": False, "C": False,
            "L": False, "M": False, "D": False, "S": False, "E": False
        }

    def toggle_key(self, key):
        """Toggles the active state of a key."""
        if key in self.active_keys:
            self.active_keys[key] = not self.active_keys[key]


key_function = KeyFunction()


def save_pattern_to_memory(grid, color_map, label):
    """
    Saves a specific grid pattern and its corresponding colors to memory.
    """
    pattern = {
        "label": label,
        "grid": grid.tolist(),
        "color_map": color_map.tolist()
    }
    if not os.path.exists(MEMORY_FILE):
        memory_data = []
    else:
        with open(MEMORY_FILE, "r") as file:
            memory_data = json.load(file)

    # Replace duplicate labels
    memory_data = [p for p in memory_data if p["label"] != label]
    memory_data.append(pattern)

    with open(MEMORY_FILE, "w") as file:
        json.dump(memory_data, file, indent=4)
    print(f"Pattern '{label}' saved successfully.")


def load_learned_patterns():
    """
    Loads all stored patterns from memory.
    """
    if not os.path.exists(MEMORY_FILE):
        return []
    with open(MEMORY_FILE, "r") as file:
        return json.load(file)


def remove_pattern(label):
    """
    Deletes a pattern from memory by label.
    """
    if not os.path.exists(MEMORY_FILE):
        return
    with open(MEMORY_FILE, "r") as file:
        memory_data = json.load(file)
    memory_data = [p for p in memory_data if p["label"] != label]
    with open(MEMORY_FILE, "w") as file:
        json.dump(memory_data, file, indent=4)
    print(f"Pattern '{label}' deleted successfully.")


def draw_recall_menu(screen, patterns):
    """
    Displays the recall menu for managing saved patterns.
    """
    font = pygame.font.Font(None, 24)
    title = font.render("Recall Menu: Press [1-9] to load, [DEL] to delete", True, (255, 255, 255))
    screen.blit(title, (10, 10))
    for i, pattern in enumerate(patterns[:9]):
        label = font.render(f"{i + 1}. {pattern['label']}", True, (255, 255, 255))
        screen.blit(label, (10, 40 + i * 20))


def propagate_with_memory(grid, color_map):
    """
    Uses learned patterns for enhanced propagation.
    """
    patterns = load_learned_patterns()
    for pattern in patterns:
        stored_grid = np.array(pattern["grid"], dtype=bool)
        stored_color_map = np.array(pattern["color_map"], dtype=int)

        # Search for matches in the grid
        for row in range(ROWS - stored_grid.shape[0] + 1):
            for col in range(COLS - stored_grid.shape[1] + 1):
                sub_grid = grid[row:row + stored_grid.shape[0], col:col + stored_grid.shape[1]]
                if np.array_equal(sub_grid, stored_grid):
                    grid[row:row + stored_grid.shape[0], col:col + stored_grid.shape[1]] = stored_grid
                    color_map[row:row + stored_grid.shape[0], col:col + stored_grid.shape[1]] = stored_color_map
    return grid, color_map


def draw_grid(screen, grid, color_map):
    """
    Draws the grid on the screen.
    """
    for row in range(ROWS):
        for col in range(COLS):
            color = tuple(color_map[row, col])
            rect = pygame.Rect(col * CELL_SIZE, row * CELL_SIZE, CELL_SIZE, CELL_SIZE)
            pygame.draw.rect(screen, color, rect)


def draw_legend(screen):
    """
    Draws the legend with dynamic toggle indicators.
    """
    font = pygame.font.Font(None, 24)
    legend_texts = [
        "R - Random grid",
        "P - Pause/Play simulation",
        "C - Clear grid",
        "L - Learning mode (paused only)",
        "M - Load learned symbols",
        "D - Toggle Mandala mode",
        "S - Save learned symbols",
        "E - Recall menu"
    ]

    for i, text in enumerate(legend_texts):
        label = font.render(text, True, (255, 255, 255))
        screen.blit(label, (10, 10 + i * 20))


def main():
    """
    Main game loop for running the Game of Life program.
    """
    pygame.init()
    screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
    clock = pygame.time.Clock()

    grid = np.random.choice([False, True], size=(ROWS, COLS), p=[0.8, 0.2])
    color_map = np.array([[generate_random_color() if grid[row, col] else [0, 0, 0]
                           for col in range(COLS)] for row in range(ROWS)])

    running = True
    paused = False
    learning_mode = False
    recall_mode = False

    while running:
        screen.fill((0, 0, 0))

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            if event.type == pygame.KEYDOWN:
                key = pygame.key.name(event.key).upper()
                if key == "P":
                    paused = not paused
                if key == "L" and paused:  # Enter learning mode
                    learning_mode = not learning_mode
                if key == "E":  # Enter recall menu
                    recall_mode = not recall_mode

        # Drawing and grid updates
        if not paused:
            grid, color_map = update_grid(grid, color_map)

        if learning_mode:
            draw_legend(screen)
        elif recall_mode:
            patterns = load_learned_patterns()
            draw_recall_menu(screen, patterns)

        draw_grid(screen, grid, color_map)
        draw_legend(screen)

        pygame.display.flip()
        clock.tick(10)

    pygame.quit()


if __name__ == "__main__":
    main()