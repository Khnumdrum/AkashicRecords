TRANSPARENCY FIX SCANNER WINDOW

def initialize_ui(self):
    """
    Initializes the User Interface with Tkinter.
    """
    # Main application window
    self.root = tk.Tk()
    self.root.title("Codex Nexus")
    self.root.geometry("600x400")

    # Ensure full opacity (no transparency issues)
    self.root.wm_attributes('-alpha', 1.0)

    # Frame for buttons
    btn_frame = tk.Frame(self.root)
    btn_frame.pack(pady=10)

    # Buttons
    load_btn = tk.Button(btn_frame, text="Load File", command=self.load_file)
    load_btn.grid(row=0, column=0, padx=5)

    scan_btn = tk.Button(btn_frame, text="Run Diagnostics", command=self.run_diagnostics)
    scan_btn.grid(row=0, column=1, padx=5)

    quit_btn = tk.Button(btn_frame, text="Quit", command=self.root.quit)
    quit_btn.grid(row=0, column=2, padx=5)

    # Text area for displaying results
    self.text_area = tk.Text(self.root, wrap="word", height=15)
    self.text_area.pack(padx=10, pady=10, fill="both", expand=True)

    # Start the Tkinter event loop
    self.root.mainloop()

#self.root.wm_attributes('-alpha', 1.0)  # Ensures no transparency issues
.# key attribute to resolve opaque#


#consecutive lines fix + user interface custom error definition+ feedback#

class Diagnostics:
    """
    Handles error tracking, severity categorization, and calibration data.
    """

    def scan_code(self, code):
        """
        Scans the code for empty lines and other potential issues.
        :param code: The code to analyze
        :return: Diagnostic report
        """
        lines = code.split("\n")
        report = []
        previous_empty = False  # Tracks consecutive empty lines

        for i, line in enumerate(lines, start=1):
            if not line.strip():  # Empty line detected
                if previous_empty:  # Flag consecutive empty lines
                    report.append(f"Line {i}: Redundant empty line.")
                previous_empty = True
            else:
                previous_empty = False

        if report:
            return "Diagnostics Report:\n" + "\n".join(report)
        else:
            return "Diagnostics Report:\nNo issues found. Code looks clean!"

#CORE CODE MANAGEMENT + moduel integration diagnostics prior int + CODE PREVIEW#

class Integrator:
    """
    Integrates new modules into the core code with error detection and conflict resolution.
    """

    def __init__(self):
        self.core_code = None  # Placeholder for core code storage

    def save_core_code(self, code):
        """
        Saves the current working code as the core code.
        :param code: The code to save as the core code
        """
        self.core_code = code
        print("Core code saved successfully.")

    def load_core_code(self):
        """
        Loads the saved core code for integration.
        :return: The core code
        """
        if not self.core_code:
            print("No core code found.")
            return None
        return self.core_code

    def integrate_module(self, new_module):
        """
        Integrates a new module into the core code.
        :param new_module: The code of the new module
        :return: Preview of the merged code or error report
        """
        if not self.core_code:
            print("Core code not initialized. Save core code first.")
            return None

        print("Analyzing new module for integration...")
        # TODO: Implement deeper conflict resolution (imports, naming overlaps, etc.)
        conflicts = self.detect_conflicts(new_module)
        if conflicts:
            print("Conflicts detected:")
            for conflict in conflicts:
                print(f"- {conflict}")
            return "Integration halted due to conflicts."

        # Merge the new module into the core code
        integrated_code = self.core_code + "\n\n# Integrated Module\n" + new_module
        return integrated_code

    def detect_conflicts(self, new_module):
        """
        Detects conflicts between core code and the new module.
        :param new_module: The code of the new module
        :return: List of conflicts
        """
        # Placeholder: Basic detection (e.g., duplicate function names)
        conflicts = []
        core_code_lines = self.core_code.split("\n")
        new_module_lines = new_module.split("\n")

        for line in new_module_lines:
            if line.strip().startswith("def ") or line.strip().startswith("class "):
                name = line.split()[1].split("(")[0]  # Extract name of function/class
                if any(f"def {name}(" in line or f"class {name}(" in line for line in core_code_lines):
                    conflicts.append(f"Duplicate name detected: {name}")
        return conflicts


# Tensor diagnostics module propersistion #
class TensorInterpreter:
    """
    Observes, translates, and interprets tensor outputs.
    """

    def analyze_tensor(self, tensor, name="Tensor"):
        """
        Analyzes a tensor and provides detailed insights.
        :param tensor: The tensor to analyze
        :param name: Optional name of the tensor
        """
        print(f"Analyzing {name}...")
        print(f"Shape: {tensor.shape}")
        print(f"Data Type: {tensor.dtype}")
        print(f"Values: {tensor}")

    def compare_tensors(self, tensor1, tensor2):
        """
        Compares two tensors for shape compatibility and content.
        :param tensor1: First tensor
        :param tensor2: Second tensor
        :return: Comparison result
        """
        print("Comparing tensors...")
        if tensor1.shape != tensor2.shape:
            print("Shape mismatch detected.")
            return False
        if not (tensor1 == tensor2).all():
            print("Content mismatch detected.")
            return False
        print("Tensors are identical.")
        return True

    def visualize_tensor(self, tensor):
        """
        Visualizes a tensor (if applicable) using Matplotlib.
        :param tensor: The tensor to visualize
        """
        import matplotlib.pyplot as plt
        import numpy as np

        if tensor.ndim == 1:
            plt.plot(tensor)
        elif tensor.ndim == 2:
            plt.imshow(tensor, cmap="viridis", interpolation="nearest")
        else:
            print("Visualization not supported for tensors with more than 2 dimensions.")
            return
        plt.colorbar()
        plt.title("Tensor Visualization")
        plt.show()

#TENSOR TO MAIN UPDATE#
class Scanner:
    """
    Observes, translates, and interprets outputs, including tensor coherence based on learned core code.
    """

    def __init__(self):
        self.tensor_baseline = {}  # Dictionary to store learned tensor baselines

    def learn_core_tensors(self, tensor_dict):
        """
        Learns tensor shapes and values from the core code.
        :param tensor_dict: Dictionary of tensors (e.g., {'tensor_name': tensor_object})
        """
        print("Learning tensor baselines from core code...")
        for name, tensor in tensor_dict.items():
            self.tensor_baseline[name] = {
                "shape": tensor.shape,
                "dtype": tensor.dtype,
                "values": tensor
            }
        print("Core tensor baseline learned successfully.")

    def interpret_tensor(self, tensor, name="Unknown Tensor"):
        """
        Interprets a tensor and compares it against the baseline.
        :param tensor: Tensor to analyze
        :param name: Name of the tensor
        """
        print(f"Interpreting tensor: {name}")
        if name not in self.tensor_baseline:
            print(f"Tensor {name} not found in baseline. Treating as new.")
            return

        baseline = self.tensor_baseline[name]
        if tensor.shape != baseline["shape"]:
            print(f"Shape mismatch detected for {name}. Expected {baseline['shape']}, got {tensor.shape}.")
        if tensor.dtype != baseline["dtype"]:
            print(f"Data type mismatch detected for {name}. Expected {baseline['dtype']}, got {tensor.dtype}.")
        if not (tensor == baseline["values"]).all():
            print(f"Value mismatch detected for {name}. Differences found.")
        else:
            print(f"{name} matches the baseline.")

    def scan_new_tensors(self, tensor_dict):
        """
        Scans tensors from a new module and compares them to the learned baselines.
        :param tensor_dict: Dictionary of tensors from the new module
        """
        print("Scanning new tensors...")
        for name, tensor in tensor_dict.items():
            self.interpret_tensor(tensor, name=name)

